<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>基础及主要功能主要包括以下几个方面:
		<script type="text/javascript">
//			es6的学习笔记
//          第一方面：let和const
//					let命令也用于声明对象,但是它的作用域为局部,不存在变量提升,并且在代码块内,使用let命令声明变量之前,该变量都是不可用的,
//					 这在语法上称为"暂时性死区"
//                        注释:1 变量提升:①JavaScript中,函数及变量的声明都将被提升至函数的最顶部  ②JavaScript中,变量可以在使用后声明,
//                        		即变量可以先使用再声明,而且JavaScript中只有变量的声明会提升,变量的初始化不会提升
//								栗子:①
										console.log("变量声明提升，变量初始化未提升:"+def);//输出undefined
										var def=5;
//									 ①.1
//										console.log("变量未声明："+deft);//报错 Uncaught ReferenceError: deft is not defined
//									
//									  由①和 ①.1可以看出，变量def发生了变量提升，并且def的初始化没有被提升，console首先使用了变量def，
//									  但此时def并没有被赋值（没有赋值的变量的默认值是undefined），所以输出undefined
//								2 暂时性死区: ①只要块级作用域内存在let命令,那么,它所声明的变量便被"绑定"在这个区域,不再受外部的影响,
//								  并且在代码块内，使用let命令声明变量之前，该变量都是不可用的
								console.log("变量已声明并且初始化："+def);
								function varab(){
//									console.log("块级作用域内存在let命令，该变量用let声明之前："+def);//报错 Uncaught ReferenceError: def is not defined
									let def;
									console.log("块级作用域内存在let命令，该变量用let声明之后（初始化不提升）："+def);
									def=8;
									console.log("块级作用域内存在let命令，该变量用let声明并初始化后，不受外部变量def的影响："+def);
									
								}
								varab();
//			        const命令声明一个只读的常量,一旦声明,常量的值就不能改变，const命令也存在暂时性死区，不会变量提升
//			第二方面:iterable类型	
//					为了统一集合类型,es6标准引入了新的iterable类型,Array,Map,Set都属于iterable类型,具有iterable类型的集合可以通过新的
//					for...of循环来遍历
					//Array数据结构类型
					var  a=["a","b","c"];
					//Set是ES6提供的新型数据结构，与Array类似，但是成员的值都是唯一的
					var s=new Set(["a","b","c","c","b"]);
					//Map是js的对象，本质上是键值对的集合（与传统的只能用字符串当键相比，Map的键的范围不限于字符串，各种类型的值（包括对象）都可以当作键）。
					var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
					m.set('Adam', 67);
					for(x of a){
//						console.log("Array数据结构采用for of 方法："+x);
					}
					for(x of s){
//						console.log("Set数据结构采用for of 方法："+x);
					}
					for(x of m){
//						console.log("Set数据结构采用for of 方法："+x);	
					}
					;
		//          输出结果如下：
		//			Array数据结构采用for of 方法：a
		//			Array数据结构采用for of 方法：b
		//			Array数据结构采用for of 方法：c
		//			Set数据结构采用for of 方法：a
		//			Set数据结构采用for of 方法：b
		//			Set数据结构采用for of 方法：c
		//			Set数据结构采用for of 方法：1,x
		//			Set数据结构采用for of 方法：2,y
		//			Set数据结构采用for of 方法：3,z
					var obj = {
					    birth: 1990,
					    getAge: function () {
					        var b = this.birth; // 1990
					        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
					        console.log(this);
					        return fn();
					    }
					   
					};
					obj.getAge();


//			第三方面:解构赋值
//					     解构:ES6允许按照一定的模式,从数组和对象中提取值,对变量进行赋值
//					     数组的解构赋值:从数组中提取值,按照对应的位置,对变量进行赋值
//					     对象的结构赋值:解构不仅可以用于数组还可以用于对象;对象的解构赋值与数组有一个重要的
//						不同,数组的元素是按照次序排列的,变量的取值由它的次序决定,但是对象的属性没有次序,变量
//						必须与属性同名,才能取到正确的值
//                                  栗子:①
									     let [e, f, g]=[1, 2, 3];
									      console.log("数组解构赋值变量e:"+e);
//									       输出: 数组解构赋值变量e:1
//									     ②
										let {foo,baz}={foo:'myfoo',baz:'mybaz'};
										console.log("对象的解构赋值foo:"+foo);
//									      输出: 对象的解构赋值foo:myfoo
										let {fun,bay}={fun:'myfoo',baz:'mybaz'};
										console.log("对象的解构赋值bay:"+bay);
//									     输出: 对象的解构赋值bay:undefined
//			第四方面:箭头函数
//					ES6允许使用箭头定义函数,ES6使用箭头操作符是为了简化函数的写法,操作符左边是参数,
//					操作符右边是具体操作和返回值
				
		</script>
	</head>
	<body>
	</body>
</html>
